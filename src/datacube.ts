import { namedNode, variable } from "@rdfjs/data-model";
import { NamedNode } from "rdf-js";
import { Generator as SparqlGenerator } from "sparqljs";
import DataSet, { IDataSetOptions, Label } from "./dataset";
import { generateLangCoalesce, generateLangOptionals, prefixes } from "./query/utils";
import SparqlFetcher, { ISparqlFetcherOptions } from "./sparqlfetcher";
import { SelectQuery } from "./sparqljs";

export interface ICubeOptions {
  languages?: string[];
  fetcher?: ISparqlFetcherOptions;
}

export type SerializedDataCube = {
  endpoint: string,
  languages: string[],
  datasets: string[],
};

export default class DataCube {
  /**
   * Deserializes a DataCube from JSON generated by DataCube#toJSON
   */
  public static fromJSON(json: string): DataCube {
    const obj: SerializedDataCube = JSON.parse(json);
    const datacube = new DataCube(obj.endpoint, {
      languages: obj.languages,
    });
    datacube.cachedDatasets = obj.datasets.reduce((map, str) => {
      const dataset: DataSet = DataSet.fromJSON(str);
      map.set(dataset.iri, dataset);
      return map;
    }, new Map());
    return datacube;
  }

  private endpoint: string;
  private languages: string[];
  private fetcher: SparqlFetcher;
  private cachedDatasets: Map<string, DataSet>;
  private allDatasetsLoaded: boolean = false;
  private cachedGraphs: NamedNode[];
  private graphsLoaded: boolean = false;

  /**
   * A DataCube queries a SPARQL endpoint and retrieves [[DataSet]]s and
   * their [[Dimension]]s, [[Measure]]s and [[Attribute]]s.
   * @class DataCube
   * @param endpoint SPARQL endpoint
   * @param options Options
   * @param options.languages Languages in which to get the labels, by priority, e.g. `["de", "en"]`.
   * Passed down to [[DataSet]]s and [[DataSetQuery]].
   */
  constructor(endpoint: string, options: ICubeOptions = {}) {
    this.endpoint = endpoint;
    this.languages = options.languages || ["de", "it"];
    this.fetcher = new SparqlFetcher(endpoint, options.fetcher || {});
    this.cachedDatasets = new Map();
    this.cachedGraphs = [];
  }

  /**
   * Serializes a DataCube to JSON in a way that makes it deserializable
   * by calling DataCube#fromJSON
   */
  public toJSON(): string {
    const obj: SerializedDataCube = {
      endpoint: this.endpoint,
      languages: this.languages,
      datasets: Array.from(this.cachedDatasets.values()).map((dataset) => dataset.toJSON()),
    };
    return JSON.stringify(obj);
  }

  /**
   * Fetch all [[DataSet]]s from the endpoint.
   */
  public async datasets(): Promise<DataSet[]> {
    if (this.allDatasetsLoaded) {
      return Array.from(this.cachedDatasets.values());
    }

    const sparql = this.generateQuery();
    const queryResult = await this.fetcher.select(sparql);
    this.cacheDatasets(queryResult);
    this.allDatasetsLoaded = true;
    return Array.from(this.cachedDatasets.values());
  }

  /**
   * Fetch a [[DataSet]] by its IRI.
   *
   * @param iri IRI of the DataSet to return.
   */
  public async datasetByIri(dataSetIri: string): Promise<DataSet> {
    const found = Array.from(this.cachedDatasets.values()).find((dataset) => dataset.iri === dataSetIri);
    if (found) {
      return found;
    }
    const sparql = this.generateQuery({ dataSetIri: namedNode(dataSetIri) });
    const queryResult = await this.fetcher.select(sparql);
    if (!queryResult.length) {
      throw new Error(`No dataset with iri <${dataSetIri}> on ${this.endpoint}`);
    }
    this.cacheDatasets(queryResult);
    return this.datasetByIri(dataSetIri);
  }

  /**
   * Fetch [[DataSet]]s by their graph IRI.
   *
   * @param graphIri IRI of the graph to look for in all DataSets.
   */
  public async datasetsByGraphIri(iri: string): Promise<DataSet[]> {
    const datasets = Array.from(this.cachedDatasets.values())
      .filter((ds) => ds.graphIri === iri);
    if (datasets.length) {
      return datasets;
    }
    const graphIri = namedNode(iri);

    const sparql = this.generateQuery({ graphIri });
    const queryResult = await this.fetcher.select(sparql);
    if (!queryResult.length) {
      // avoid infinite recursion
      throw new Error(`Cannot find graph <${iri}> in ${this.endpoint}`);
    }
    this.cacheDatasets(queryResult.map((result) => {
      result.graphIri = graphIri;
      return result;
    }));
    return this.datasetsByGraphIri(iri);
  }

  /**
   * Fetch all graphs from the endpoint.
   */
  public async graphs(): Promise<NamedNode[]> {
    if (this.graphsLoaded) {
      return this.cachedGraphs;
    }
    const query = `
      PREFIX qb: <http://purl.org/linked-data/cube#>
      SELECT DISTINCT ?graph WHERE {
        GRAPH ?graph {
          ?dataset a qb:DataSet .
        }
      }
    `;
    const graphs = await this.fetcher.select(query);
    this.graphsLoaded = true;
    return this.cachedGraphs = graphs.map(({ graph }) => graph);
  }

  private cacheDatasets(datasets: Array<{ iri: NamedNode, label: Label, graphIri: string }>) {
    const datasetsByIri = datasets.reduce((acc, { iri, label, graphIri }) => {
      if (!acc[iri.value]) {
        acc[iri.value] = {
          iri,
          labels: [],
          graphIri,
          languages: this.languages,
        };
      }
      acc[iri.value].labels.push({
        value: label.value,
        language: label.language,
      });
      return acc;
    }, {});

    Object.entries(datasetsByIri)
      .forEach(([iri, dataset]: [string, IDataSetOptions]) => {
        this.cachedDatasets.set(iri, new DataSet(this.endpoint, dataset));
      });
  }

  private generateQuery({graphIri, dataSetIri}: {graphIri?: NamedNode, dataSetIri?: NamedNode} = {}) {
    const graphIriBinding = variable("graphIri");
    const iriBinding = variable("iri");
    const labelBinding = variable("label");

    const query: SelectQuery = {
      prefixes,
      queryType: "SELECT",
      variables: [
        iriBinding,
        graphIriBinding,
        labelBinding,
      ],
      where: [
        {
          type: "graph",
          name: graphIri || graphIriBinding,
          patterns: [
            {
              type: "bgp",
              triples: [
                {
                  subject: iriBinding,
                  predicate: namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"),
                  object: namedNode("http://purl.org/linked-data/cube#DataSet"),
                },
              ],
            },
            ...generateLangOptionals(iriBinding, labelBinding, this.languages),
          ],
        },
        generateLangCoalesce(labelBinding, this.languages),
      ],
      type: "query",
    };
    if (dataSetIri) {
      query.where.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "=",
          args: [
            iriBinding,
            dataSetIri,
          ],
        },
      });
    }

    const generator = new SparqlGenerator({ allPrefixes: true });
    return generator.stringify(query);
  }
}
